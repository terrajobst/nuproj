<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <Import Project="$(CustomBeforeNuProjTargets)" Condition="'$(CustomBeforeNuProjTargets)' != '' and Exists('$(CustomBeforeNuProjTargets)')"/>

  <!--
      NUSPEC PATH
  -->

  <PropertyGroup>
    <NuSpecPath>$(IntermediateOutputPath)$(Id).nuspec</NuSpecPath>
  </PropertyGroup>

  <!--
      OUTPUT PATHS

      These properties aren't passed to NuGet.exe - they're implicit. However, we need to know the output paths
      at several occasions (e.g. incremental build or clean up) so we want a central spot to capture those.
  -->

  <PropertyGroup>
    <NuGetOutputPath>$([System.IO.Path]::GetFullPath('$(OutDir)$(Id).$(Version).nupkg'))</NuGetOutputPath>
    <NuGetSymbolsOutputPath>$(OutDir)$(Id).$(Version).symbols.nupkg</NuGetSymbolsOutputPath>
  </PropertyGroup>

  <!--
      MSBuildAllProjects is used to keep track of all projects the build depends on.
      We make all targets depending on it to make sure everything rebuilds.
  -->

  <PropertyGroup>
    <MSBuildAllProjects Condition="Exists('$(MSBuildProjectFullPath)')">$(MSBuildAllProjects);$(MSBuildProjectFullPath)</MSBuildAllProjects>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <!--
      OUTPUT GROUPS

      These are the groups we are using to discover outputs from our project references.
  -->

  <PropertyGroup>
    <ProjectOutputGroups>
      BuiltProjectOutputGroup;
      BuiltProjectOutputGroupDependencies;
      DebugSymbolsProjectOutputGroup;
      DebugSymbolsProjectOutputGroupDependencies;
      DocumentationProjectOutputGroup;
      DocumentationProjectOutputGroupDependencies;
      SatelliteDllsProjectOutputGroup;
      SatelliteDllsProjectOutputGroupDependencies;
      SGenFilesOutputGroup;
      SGenFilesOutputGroupDependencies;
    </ProjectOutputGroups>
  </PropertyGroup>

  <!--
      PROJECT PROPERTIES

      These are the properties we forward to our project references.
  -->

  <PropertyGroup>
    <ProjectProperties>
      Configuration=$(Configuration);
      Platform=$(Platform);
    </ProjectProperties>
  </PropertyGroup>

  <!--
      CUSTOM TASKS
  -->

  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="GenerateNuSpec" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="NuGetPack" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="AssignTargetFramework" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="ReadPackagesConfig" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="ReadPdbSourceFiles" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="AssignSourceTargetPaths" />

  <!--
    ===================================================================================================================
    SplitProjectReferences
    ===================================================================================================================

    This target will split the project references into NuProj project references and non-NuProj references.

    INPUTS:
        @(ProjectReference)            The project references

    OUTPUTS:
        @(_NuProjProjectReference)     References to NuProj projects.
        @(_NonNuProjProjectReference)  References to regular, i.e. non-NuProj projects.

    =================================================================================================================== -->

    <Target Name="SplitProjectReferences">
        <ItemGroup>
            <_NuProjProjectReference Include="@(ProjectReference)"
                                     Condition="'%(ProjectReference.Extension)' == '.nuproj'" />
            <_NonNuProjProjectReference Include="@(ProjectReference)"
                                        Condition="'%(ProjectReference.Extension)' != '.nuproj'" />
        </ItemGroup>
    </Target>

  <!--
    ===================================================================================================================
    ExpandProjectReferences
    ===================================================================================================================

    This target will get the build outputs of the project references

    INPUTS:
        @(ProjectReference)         The project references

    OUTPUTS:
        @(Library)                  The library Files to be packaged

    =================================================================================================================== -->

    <Target Name="ExpandProjectReferences"
            DependsOnTargets="SplitProjectReferences"
            Inputs="%(_NonNuProjProjectReference.Identity)"
            Outputs="fake">

        <!-- First let's make sure that the project reference has been fully build -->

        <MSBuild Targets="Build"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)" />

        <!-- Now we can ask for the output and all dependencies. -->

        <MSBuild Targets="$(ProjectOutputGroups)"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)">
            <Output TaskParameter="TargetOutputs"
                    ItemName="_NonNuProjProjectOutput" />
        </MSBuild>

        <!-- Since the dependencies include platform assemblies, we'll filter
             out all files that don't exist in this project's output folder.
             First we need the project's output folder. The easiest way is
             to ask for the target path and then use a property function to
             get the directory name. -->

        <MSBuild Targets="GetTargetPath"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)">
            <Output TaskParameter="TargetOutputs"
                    PropertyName="_NonNuProjProjectTargetPath" />
        </MSBuild>

        <PropertyGroup>
             <_NonNuProjProjectTargetPath>$([System.IO.Path]::GetDirectoryName($(_NonNuProjProjectTargetPath)))\</_NonNuProjProjectTargetPath>
        </PropertyGroup>

        <!-- Now we can filter the outputs based on whether they exist
             in the project's output folder. -->

        <ItemGroup>
            <_NonNuProjProjectOutput Remove="@(_NonNuProjProjectOutput)"
                                     Condition="!Exists('$(_NonNuProjProjectTargetPath)%(_NonNuProjProjectOutput.Filename)%(_NonNuProjProjectOutput.Extension)') "/>
        </ItemGroup>

        <!-- In order to package the the files in the correct folder in the
             NuGet package we need need to know the target framework moniker. -->

        <MSBuild Targets="GetTargetFrameworkMoniker"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)">
            <Output TaskParameter="TargetOutputs"
                    PropertyName="_NonNuProjProjectTargetFrameworkMoniker" />
        </MSBuild>

        <!-- In order to add custom metadata, we need to create a new item list -->

        <CreateItem Include="@(_NonNuProjProjectOutput)"
                    AdditionalMetadata="TargetFrameworkMoniker=$(_NonNuProjProjectTargetFrameworkMoniker)">
            <Output TaskParameter="Include"
                    ItemName="_NonNuProjProjectOutputWithTargetFrameworkMoniker"/>
        </CreateItem>

        <!-- Now we can run the AssignTargetFramework task. It will use the
             %(TargetFrameworkMoniker) metadata to create the %(TargetPath).
             The target path will use the NuGet lib convention, e.g.
             lib\net40\foo.dll -->

        <AssignTargetFramework OutputsWithTargetFrameworkInformation="@(_NonNuProjProjectOutputWithTargetFrameworkMoniker)">
            <Output TaskParameter="Libraries"
                    ItemName="Library" />
        </AssignTargetFramework>

    </Target>

    <!--
    ===================================================================================================================
    ConvertItems
    ===================================================================================================================

    This target is converting specialized items groups into the general <File> item list that indicates what should
    be packaged.

    INPUTS:
        @(Library)                  Library items to be packaged
        @(Content)                  Content items to be packaged

    OUTPUTS:
        @(File)                     The <File> elements to be packaged.

    =================================================================================================================== -->

  <Target Name="ConvertItems"
          DependsOnTargets="ExpandProjectReferences">
    <CreateItem Include="@(Library)"
                AdditionalMetadata="TargetPath=lib\%(Library.TargetFramework)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <ItemGroup>
      <_LinkedContentFiles Include="@(Content)"
                           Condition="'%(Content.Link)' != ''" />
      <_UnlinkedContentFiles Include="@(Content)"
                             Condition="'%(Content.Link)' == ''" />
    </ItemGroup>
    <CreateItem Include="@(_LinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(Link)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <CreateItem Include="@(_UnlinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(RelativeDir)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <CreateItem Include="@(Tool)"
                AdditionalMetadata="TargetPath=tools\%(Tool.TargetPath)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>

    <!-- We need to special case library files in later phases. In order to make this
         easier, we add custom metadata 'IsLibrary' that indiates whether the file is
         targeting the lib folder or not. -->

    <ItemGroup>
      <_FileWithIsLibrary Include="@(File)"
                          Condition="'%(File.TargetPath)' == 'lib' OR
                                     $([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib\')) OR
                                     $([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib/'))">
        <IsLibrary>True</IsLibrary>
      </_FileWithIsLibrary>
      <_FileWithIsLibrary Include="@(File)"
                          Condition="'%(File.TargetPath)' != 'lib' AND
                                     !$([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib\')) AND
                                     !$([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib/'))">
        <IsLibrary>False</IsLibrary>
      </_FileWithIsLibrary>
      <File Remove="@(File)" />
      <File Include="@(_FileWithIsLibrary)" />
    </ItemGroup>

  </Target>

  <!--
    ===================================================================================================================
    GenerateNuSpec
    ===================================================================================================================

    This target is creates the .nuspec file that is used to create the NuGet package (.nupkg).

    INPUTS:
        $(NuSpecPath)                  The path where the NuSpec should be written to.

        $(Id),
        $(Version),
        $(Title),
        $(Authors),
        $(Owners),
        $(Description),
        $(ReleaseNotes),
        $(Summary),
        $(Language),
        $(ProjectUrl),
        $(IconUrl),
        $(LicenseUrl),
        $(Copyright),
        $(RequireLicenseAcceptance),
        $(Tags),
        $(DevelopmentDependency)       General properties of the NuSpec

        @(Dependency)                  (Optional) The NuGet package dependencies
        @(FrameworkReference)          (Optional) Framework assembly references
        @(Reference)                   (Optional) The assembly references
        @(File)                        (Optional) The files to be packaged

    =================================================================================================================== -->

  <Target Name="GenerateNuSpec"
          Inputs="@(PackageFile);AlwaysRunEvenIfPackageFileIsEmpty"
          Outputs="$(NuSpecPath)"
          DependsOnTargets="GetPackageDependencies;GetPackageFiles;GetSourceFiles">
    <!-- Please Note:
         In order to avoid incremental build issues this target will always run.
         However, the task will make sure that it doesn't touch the file if the
         contents it would generate are identical to a previously generated
         nuspec. -->
    <GenerateNuSpec OutputFileName="$(NuSpecPath)"
                    MinClientVersion="$(MinClientVersion)"
                    Id="$(Id)"
                    Version="$(Version)"
                    Title="$(Title)"
                    Authors="$(Authors)"
                    Owners="$(Owners)"
                    Description="$(Description)"
                    ReleaseNotes="$(ReleaseNotes)"
                    Summary="$(Summary)"
                    Language="$(Language)"
                    ProjectUrl="$(ProjectUrl)"
                    IconUrl="$(IconUrl)"
                    LicenseUrl="$(LicenseUrl)"
                    Copyright="$(Copyright)"
                    RequireLicenseAcceptance="$(RequireLicenseAcceptance)"
                    Tags="$(Tags)"
                    DevelopmentDependency="$(DevelopmentDependency)"
                    Dependencies="@(Dependency)"
                    References="@(Reference)"
                    FrameworkReferences="@(FrameworkReference)"
                    Files="@(PackageFile)"/>
  </Target>

  <!--
    ===================================================================================================================
    CreatePackage
    ===================================================================================================================

    This target creates the NuGet package from a .nuspec file

    INPUTS:
        $(NuSpecPath)                  The path to the NuSpec file.
        $(OutDir)                      The path to the directory where the .nupkg should be created
        $(NuGetToolPath)               The path of the directory that contains to NuGet.exe
        $(NuGetToolExe)                The name of NuGet.exe

    =================================================================================================================== -->

  <Target Name="CreatePackage"
          Inputs="$(MSBuildAllProjects);
                  $(NuSpecPath);
                  @(File)"
          Outputs="$(NuGetOutputPath)"
          DependsOnTargets="GenerateNuSpec">
    <MakeDir Directories="$(OutDir)"
             Condition="!Exists('$(OutDir)')" />
    <NuGetPack OutputDirectory="$(OutDir)"
               NoPackageAnalysis="$(NoPackageAnalysis)"
               Symbols="$(GenerateSymbolPackage)"
               ToolPath="$(NuGetToolPath)"
               ToolExe="$(NuGetToolExe)"
               NuSpecPath="$(NuSpecPath)"/>
  </Target>

  <!--
    ===================================================================================================================
    GetPackageFiles
    ===================================================================================================================

    Gets the set of files that will be included in this package. This set will not include any files that are already
    provided by our NuGet dependencies.

    OUTPUTS:
        @(PackageFile)                        The files that will be included in this package.

    =================================================================================================================== -->

  <Target Name="GetPackageFiles"
          Returns="@(PackageFile)"
          DependsOnTargets="GetFiles;GetFileDependencies">

      <ItemGroup>

        <!-- We don't want to package libraries that come from dependencies.
             Please note that we do want to package non-library files regardless
             as we generally don't automatically pick those up from dependencies.

             This allows people to include binaries in their tools folder, for
             example.

             In order to filter based on the simple file name, we'll set the
             identity to the simple file name and record the original identity
             as new metadata that we'll use to restore afterwards.

             Since we want to only filer libraries we'll set the identity to an
             illegal file name if the packaged file isn't a library. -->

        <_FileTargetPath Include="@(File->'%(FileName)%(Extension)')"
                         Condition="'%(File.IsLibrary)' == 'True'">
            <OriginalItemSpec>%(File.Identity)</OriginalItemSpec>
        </_FileTargetPath>
        <_FileTargetPath Include="@(File->'::KEEP::')"
                         Condition="'%(File.IsLibrary)' == 'False'">
            <OriginalItemSpec>%(File.Identity)</OriginalItemSpec>
        </_FileTargetPath>

        <!-- Now we can remove all files from _FileTargetPath that come from
             dependencies. -->

        <_FileDependencyTargetPath Include="@(FileDependency->'%(FileName)%(Extension)')" />
        <_FileTargetPath Remove="@(_FileDependencyTargetPath)" />

        <!-- In order to produce the final list we have to restore the original
             identity. -->

        <PackageFile Remove="@(PackageFile)" />
        <PackageFile Include="@(_FileTargetPath->'%(OriginalItemSpec)')" />

      </ItemGroup>

  </Target>

  <!--
    ===================================================================================================================
    GetFiles
    ===================================================================================================================

    Gets the set of candidate files to be packaged. This set will also contain any files that are already provided by
    our NuGet dependencies.

    OUTPUTS:
        @(File)                        The files that are being packaged

    =================================================================================================================== -->

  <Target Name="GetFiles"
          Returns="@(File)"
          DependsOnTargets="ConvertItems" />

  <!--
    ===================================================================================================================
    GetFileDependencies
    ===================================================================================================================

    Returns the files coming from the transitive closure of all NuGet dependencies from this package.

    OUTPUTS:
        @(FileDependency)               Files coming from dependencies

    =================================================================================================================== -->

  <Target Name="GetFileDependencies"
          DependsOnTargets="GetNuProjFileDependencies;GetNuGetFileDependencies"
          Returns="@(FileDependency)">
      <ItemGroup>
          <FileDependency Include="@(NuProjFileDependency)" />
          <FileDependency Include="@(NuGetFileDependency)" />
      </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    GetNuProjFileDependencies
    ===================================================================================================================

    Returns the files coming from the transitive closure of all NuGet dependencies from this package.

    OUTPUTS:
        @(FileDependency)               Files coming from dependencies

    =================================================================================================================== -->

  <Target Name="GetNuProjFileDependencies"
          Returns="@(NuProjFileDependency)"
          DependsOnTargets="SplitProjectReferences">
      <MSBuild Targets="GetPackageFiles"
               Projects="@(_NuProjProjectReference)"
               Properties="$(ProjectProperties)">
        <Output TaskParameter="TargetOutputs"
                ItemName="NuProjFileDependency" />
      </MSBuild>
  </Target>

  <!--
    ===================================================================================================================
    GetNuGetFileDependencies
    ===================================================================================================================

    Returns the files coming from the transitive closure of all NuGet dependencies from this package.

    OUTPUTS:
        @(NuGetFileDependency)               Files coming from dependencies

    =================================================================================================================== -->

  <Target Name="GetNuGetFileDependencies"
          Returns="@(NuGetFileDependency)">
      <ItemGroup>
        <NuGetFileDependency Include="%(NuGetDependency.PackageDirectoryPath)\**\*"
                             Condition="'%(NuGetDependency.PackageDirectoryPath)' != ''" />
      </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    GetPackageDependencies
    ===================================================================================================================

    Get the direct package dependencies of this package. It doesn't include dependencies of dependencies.

    OUTPUTS:
        @(Dependency)               The NuGet dependencies of this package.

    =================================================================================================================== -->

  <Target Name="GetPackageDependencies"
          DependsOnTargets="GetNuProjPackageDependencies;GetNuGetPackageDependencies"
          Returns="@(Dependency)">
    <ItemGroup>
      <Dependency Include="@(NuProjDependency)" />
      <Dependency Include="@(NuGetDependency)" />
    </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    GetNuProjPackageDependencies
    ===================================================================================================================

    Get the direct package dependencies that come from other .nuproj files.

    OUTPUTS:
        @(NuProjDependency)               The NuGet dependencies of this package.

    =================================================================================================================== -->

  <Target Name="GetNuProjPackageDependencies"
          Returns="@(NuProjDependency)"
          DependsOnTargets="SplitProjectReferences">
      <MSBuild Targets="GetPackageIdentity"
               Projects="@(_NuProjProjectReference)"
               Properties="$(ProjectProperties)">
        <Output TaskParameter="TargetOutputs"
                ItemName="NuProjDependency" />
      </MSBuild>
  </Target>

  <!--
    ===================================================================================================================
    GetNuGetPackageDependencies
    ===================================================================================================================

    Get the direct package dependencies that come from regular, i.e. non-.nuproj NuGet dependencies.

    OUTPUTS:
        @(NuGetDependency)               The NuGet dependencies of this package.

    =================================================================================================================== -->

  <Target Name="GetNuGetPackageDependencies"
          Returns="@(NuGetDependency)">
      <ReadPackagesConfig ProjectPath="%(ProjectReference.FullPath)"
                          Condition="'%(ProjectReference.FullPath)' != ''">
        <Output TaskParameter="PackageReferences"
                ItemName="_PackageReference" />
      </ReadPackagesConfig>

      <ItemGroup Condition="'@(_PackageReference)' != ''">
        <NuGetDependency Include="@(_PackageReference)" 
                         Condition="!%(IsDevelopmentDependency)"
                         RemoveMetadata="IsDevelopmentDependency;RequireReinstallation;VersionConstraint">
          <Version Condition="'%(_PackageReference.VersionConstraint)' != ''">%(_PackageReference.VersionConstraint)</Version>
        </NuGetDependency>
      </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    GetSourceFiles
    =================================================================================================================== -->

  <Target Name="GetSourceFiles"
          DependsOnTargets="GetPackageFiles"
          Condition="'$(EmbedSourceFiles)' == 'True'"
          Returns="@(_SourceFileWithTargetPath)">
    <ItemGroup>
      <_PdbFiles Include="@(PackageFile)"
                 Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <ReadPdbSourceFiles PdbPath="%(_PdbFiles.Identity)">
      <Output TaskParameter="SourcePaths"
              ItemName="_SourceFile" />
    </ReadPdbSourceFiles>
    <!-- Some compilers (like VB) have source files listed that don't actually exist.
         Since we can only package existing files we'll need to exlude those files. -->
    <ItemGroup>
      <_SourceFile Remove="@(_SourceFile)"
                   Condition="!Exists(%(_SourceFile.Identity))" />
    </ItemGroup>
    <AssignSourceTargetPaths SourceFiles="@(_SourceFile)">
      <Output TaskParameter="SourceFilesWithTargetPath"
              ItemName="_SourceFileWithTargetPath" />
      <Output TaskParameter="SourceFilesWithTargetPath"
              ItemName="PackageFile" />
    </AssignSourceTargetPaths>
  </Target>

  <!--
    ===================================================================================================================
    GetPackageIdentity
    ===================================================================================================================

    Returns an item whose identity is the $(Id). The version is included in custom metadata item Version. This format
    is identitcal to the one used to describe package dependencies.

    OUTPUTS:
        $(_PackageIdentity)               The Id and Version of this package

    =================================================================================================================== -->

  <Target Name="GetPackageIdentity"
          Returns="@(_PackageIdentity)">
    <ItemGroup>
      <_PackageIdentity Include="$(Id)">
        <Version>$(Version)</Version>
      </_PackageIdentity>
    </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    Clean, Build, Rebuild
    ===================================================================================================================

    These are the standard targets to clean, build and rebuild a NuGet package.

    =================================================================================================================== -->

  <Target Name="Clean">
    <MSBuild Targets="Clean"
             Projects="@(ProjectReference)"
             Properties="$(ProjectProperties)" />
    <ItemGroup>
      <_ToBeDeleted Include="$(NuSpecPath)" />
      <_ToBeDeleted Include="$(NuGetOutputPath)" />
      <_ToBeDeleted Include="$(NuGetSymbolsOutputPath)" />
    </ItemGroup>
    <Delete Files="@(_ToBeDeleted)" />
  </Target>

  <Target Name="Build" DependsOnTargets="CreatePackage">
    <Message Text="$(MSBuildProjectName) -> $(NuGetOutputPath)"
             Importance="high" />
  </Target>

  <Target Name="Rebuild" DependsOnTargets="Clean;Build" />

  <Import Project="$(CustomAfterNuProjTargets)" Condition="'$(CustomAfterNuProjTargets)' != '' and Exists('$(CustomAfterNuProjTargets)')"/>

</Project>