<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <Import Project="$(CustomBeforeNuProjTargets)" Condition="'$(CustomBeforeNuProjTargets)' != '' and Exists('$(CustomBeforeNuProjTargets)')"/>

  <Import Project="ProjectReferenceClosure.targets" />


  <!--
      NUSPEC PATH
  -->

  <PropertyGroup>
    <NuSpecPath>$(IntermediateOutputPath)$(Id).nuspec</NuSpecPath>
  </PropertyGroup>

  <!--
      OUTPUT PATHS

      These properties aren't passed to NuGet.exe - they're implicit. However, we need to know the output paths
      at several occasions (e.g. incremental build or clean up) so we want a central spot to capture those.
  -->

  <PropertyGroup>
    <NuGetOutputPath>$([System.IO.Path]::GetFullPath('$(OutDir)$(Id).$(Version).nupkg'))</NuGetOutputPath>
    <NuGetSymbolsOutputPath>$(OutDir)$(Id).$(Version).symbols.nupkg</NuGetSymbolsOutputPath>
  </PropertyGroup>

  <!--
      MSBuildAllProjects is used to keep track of all projects the build depends on.
      We make all targets depending on it to make sure everything rebuilds.
  -->

  <PropertyGroup>
    <MSBuildAllProjects Condition="Exists('$(MSBuildProjectFullPath)')">$(MSBuildAllProjects);$(MSBuildProjectFullPath)</MSBuildAllProjects>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <!--
      OUTPUT GROUPS

      These are the groups we are using to discover outputs from our project references.
  -->

  <PropertyGroup>
    <ProjectOutputGroups>
      BuiltProjectOutputGroup;
      BuiltProjectOutputGroupDependencies;
      DebugSymbolsProjectOutputGroup;
      DebugSymbolsProjectOutputGroupDependencies;
      DocumentationProjectOutputGroup;
      DocumentationProjectOutputGroupDependencies;
      SatelliteDllsProjectOutputGroup;
      SatelliteDllsProjectOutputGroupDependencies;
      SGenFilesOutputGroup;
      SGenFilesOutputGroupDependencies;
    </ProjectOutputGroups>
  </PropertyGroup>

  <!--
      PROJECT PROPERTIES

      These are the properties we forward to our project references.
  -->

  <PropertyGroup>
    <ProjectProperties>
      Configuration=$(Configuration);
      Platform=$(Platform);
      CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileDirectory)ProjectReferenceClosure.targets
    </ProjectProperties>
  </PropertyGroup>

  <!--
      CUSTOM TASKS
  -->

  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="GenerateNuSpec" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="NuGetPack" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="AssignTargetFramework" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="ReadPackagesConfig" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="ReadPdbSourceFiles" />
  <UsingTask AssemblyFile="$(NuProjTasksPath)" TaskName="AssignSourceTargetPaths" />

  <!--
    ===================================================================================================================
    SplitProjectReferences
    ===================================================================================================================

    This target will split the project references into NuProj project references and non-NuProj references.

    INPUTS:
        @(ProjectReference)            The project references

    OUTPUTS:
        @(_NuProjProjectReference)     References to NuProj projects.
        @(_NonNuProjProjectReference)  References to regular, i.e. non-NuProj projects.

    =================================================================================================================== -->

    <Target Name="SplitProjectReferences">
        <ItemGroup>
            <_NuProjProjectReference Include="@(ProjectReference)"
                                     Condition="'%(ProjectReference.Extension)' == '.nuproj'" />
            <_NonNuProjProjectReference Include="@(ProjectReference)"
                                        Condition="'%(ProjectReference.Extension)' != '.nuproj'" />
        </ItemGroup>
    </Target>

  <!--
    ===================================================================================================================
    ExpandProjectReferences
    ===================================================================================================================

    This target will get the build outputs of the project references

    INPUTS:
        @(ProjectReference)         The project references

    OUTPUTS:
        @(Library)                  The library items to be packaged

    =================================================================================================================== -->

    <Target Name="ExpandProjectReferences"
            DependsOnTargets="SplitProjectReferences"
            Inputs="%(_NonNuProjProjectReference.Identity)"
            Outputs="fake">

        <!-- First let's make sure that the project reference has been fully build -->

        <MSBuild Targets="Build"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)" />

        <!-- Now we can ask for the output and all dependencies. -->

        <MSBuild Targets="$(ProjectOutputGroups)"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)">
            <Output TaskParameter="TargetOutputs"
                    ItemName="_NonNuProjProjectOutput" />
        </MSBuild>

        <!-- Since the dependencies include platform assemblies, we'll filter
             out all files that don't exist in this project's output folder.
             First we need the project's output folder. The easiest way is
             to ask for the target path and then use a property function to
             get the directory name. -->

        <MSBuild Targets="GetTargetPath"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)">
            <Output TaskParameter="TargetOutputs"
                    PropertyName="_NonNuProjProjectTargetPath" />
        </MSBuild>

        <PropertyGroup>
             <_NonNuProjProjectTargetPath>$([System.IO.Path]::GetDirectoryName($(_NonNuProjProjectTargetPath)))\</_NonNuProjProjectTargetPath>
        </PropertyGroup>

        <!-- Now we can filter the outputs based on whether they exist
             in the project's output folder. -->

        <ItemGroup>
            <_NonNuProjProjectOutput Remove="@(_NonNuProjProjectOutput)"
                                     Condition="!Exists('$(_NonNuProjProjectTargetPath)%(_NonNuProjProjectOutput.Filename)%(_NonNuProjProjectOutput.Extension)') "/>
        </ItemGroup>

        <!-- In order to package the the files in the correct folder in the
             NuGet package we need need to know the target framework moniker. -->

        <MSBuild Targets="GetTargetFrameworkMoniker"
                 Projects="%(_NonNuProjProjectReference.Identity)"
                 Properties="$(ProjectProperties)">
            <Output TaskParameter="TargetOutputs"
                    PropertyName="_NonNuProjProjectTargetFrameworkMoniker" />
        </MSBuild>

        <!-- In order to add custom metadata, we need to create a new item list -->

        <CreateItem Include="@(_NonNuProjProjectOutput)"
                    AdditionalMetadata="TargetFrameworkMoniker=$(_NonNuProjProjectTargetFrameworkMoniker)">
            <Output TaskParameter="Include"
                    ItemName="_NonNuProjProjectOutputWithTargetFrameworkMoniker"/>
        </CreateItem>

        <!-- Now we can run the AssignTargetFramework task. It will use the
             %(TargetFrameworkMoniker) metadata to create the %(TargetPath).
             The target path will use the NuGet lib convention, e.g.
             lib\net40\foo.dll -->

        <AssignTargetFramework OutputsWithTargetFrameworkInformation="@(_NonNuProjProjectOutputWithTargetFrameworkMoniker)">
            <Output TaskParameter="Libraries"
                    ItemName="Library" />
        </AssignTargetFramework>

    </Target>

    <!--
    ===================================================================================================================
    ConvertItems
    ===================================================================================================================

    This target is converting specialized items groups into the general <File> item list that indicates what should
    be packaged.

    INPUTS:
        @(Library)                  Library items to be packaged
        @(Content)                  Content items to be packaged

    OUTPUTS:
        @(File)                     The <File> elements to be packaged.

    =================================================================================================================== -->

  <Target Name="ConvertItems"
          DependsOnTargets="ExpandProjectReferences">
    <CreateItem Include="@(Library)"
                AdditionalMetadata="TargetPath=lib\%(Library.TargetFramework);Type=Library">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <ItemGroup>
      <_LinkedContentFiles Include="@(Content)"
                           Condition="'%(Content.Link)' != ''" />
      <_UnlinkedContentFiles Include="@(Content)"
                             Condition="'%(Content.Link)' == ''" />
    </ItemGroup>
    <CreateItem Include="@(_LinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(Link);Type=Content">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <CreateItem Include="@(_UnlinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(RelativeDir);Type=Content">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <CreateItem Include="@(Tool)"
                AdditionalMetadata="TargetPath=tools\%(Tool.TargetPath);Type=Tool">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
  </Target>

  <!--
    ===================================================================================================================
    GenerateNuSpec
    ===================================================================================================================

    This target is creates the .nuspec file that is used to create the NuGet package (.nupkg).

    INPUTS:
        $(NuSpecPath)                  The path where the NuSpec should be written to.

        $(Id),
        $(Version),
        $(Title),
        $(Authors),
        $(Owners),
        $(Description),
        $(ReleaseNotes),
        $(Summary),
        $(Language),
        $(ProjectUrl),
        $(IconUrl),
        $(LicenseUrl),
        $(Copyright),
        $(RequireLicenseAcceptance),
        $(Tags),
        $(DevelopmentDependency)       General properties of the NuSpec

        @(Dependency)                  (Optional) The NuGet package dependencies
        @(FrameworkReference)          (Optional) Framework assembly references
        @(Reference)                   (Optional) The assembly references
        @(File)                        (Optional) The files to be packaged

    =================================================================================================================== -->

  <Target Name="GenerateNuSpec"
          Inputs="@(PackageFile)"
          Outputs="$(NuSpecPath)"
          DependsOnTargets="GetPackageDependencies;GetPackageFiles;GetSourceFiles">
    <!-- Please Note:
         In order to avoid incremental build issues this target will always run.
         However, the task will make sure that it doesn't touch the file if the
         contents it would generate are identical to a previously generated
         nuspec. -->
    <GenerateNuSpec OutputFileName="$(NuSpecPath)"
                    MinClientVersion="$(MinClientVersion)"
                    Id="$(Id)"
                    Version="$(Version)"
                    Title="$(Title)"
                    Authors="$(Authors)"
                    Owners="$(Owners)"
                    Description="$(Description)"
                    ReleaseNotes="$(ReleaseNotes)"
                    Summary="$(Summary)"
                    Language="$(Language)"
                    ProjectUrl="$(ProjectUrl)"
                    IconUrl="$(IconUrl)"
                    LicenseUrl="$(LicenseUrl)"
                    Copyright="$(Copyright)"
                    RequireLicenseAcceptance="$(RequireLicenseAcceptance)"
                    Tags="$(Tags)"
                    DevelopmentDependency="$(DevelopmentDependency)"
                    Dependencies="@(Dependency)"
                    References="@(Reference)"
                    FrameworkReferences="@(FrameworkReference)"
                    Files="@(PackageFile)"/>
  </Target>

  <!--
    ===================================================================================================================
    CreatePackage
    ===================================================================================================================

    This target creates the NuGet package from a .nuspec file

    INPUTS:
        $(NuSpecPath)                  The path to the NuSpec file.
        $(OutDir)                      The path to the directory where the .nupkg should be created
        $(NuProjToolPath)              The path of the directory that contains to NuGet.exe
        $(NuGetToolExe)                The name of NuGet.exe

    =================================================================================================================== -->

  <Target Name="CreatePackage"
          Inputs="$(MSBuildAllProjects);
                  $(NuSpecPath);
                  @(File)"
          Outputs="$(NuGetOutputPath)"
          DependsOnTargets="GenerateNuSpec">
    <MakeDir Directories="$(OutDir)"
             Condition="!Exists('$(OutDir)')" />
    <NuGetPack OutputDirectory="$(OutDir)"
               NoPackageAnalysis="$(NoPackageAnalysis)"
               Symbols="$(GenerateSymbolPackage)"
               ToolPath="$(NuProjToolPath)"
               ToolExe="$(NuGetToolExe)"
               NuSpecPath="$(NuSpecPath)"/>
  </Target>

  <!--
    ===================================================================================================================
    GetPackageFiles
    ===================================================================================================================

    Gets the set of files that will be included in this package. This set will not include any files that are already
    provided by our NuGet dependencies.

    OUTPUTS:
        @(PackageFile)                        The files that will be included in this package.

    =================================================================================================================== -->

  <Target Name="GetPackageFiles"
          Returns="@(PackageFile)"
          DependsOnTargets="GetFiles;GetFileDependencies">

      <ItemGroup>
        <!--
            We create a new item list where the identity is the simple file name
            so that we can filter out the dependencies.
        -->
        <_NonLibraryTargetPath Include="@(File->'%(FileName)%(Extension)')"
                               Condition="'%(Type)' != 'Library'">
            <OriginalItemSpec>%(File.Identity)</OriginalItemSpec>
        </_NonLibraryTargetPath>
        <_LibraryTargetPath Include="@(File->'%(FileName)%(Extension)')"
                            Condition="'%(Type)' == 'Library'">
            <OriginalItemSpec>%(File.Identity)</OriginalItemSpec>
        </_LibraryTargetPath>
        <!--
            Now we can remove all files from _LibraryTargetPath that come from dependencies.
        -->
        <_FileDependencyTargetPath Include="@(FileDependency->'%(FileName)%(Extension)')" />
        <_LibraryTargetPath Remove="@(_FileDependencyTargetPath)" />
        <!--
            In order to produce the final list we have to restore the original item spec.
        -->
        <PackageFile Remove="@(PackageFile)" />
        <PackageFile Include="@(_NonLibraryTargetPath->'%(OriginalItemSpec)')" />
        <PackageFile Include="@(_LibraryTargetPath->'%(OriginalItemSpec)')" />
      </ItemGroup>

  </Target>

  <!--
    ===================================================================================================================
    GetFiles
    ===================================================================================================================

    Gets the set of candidate files to be packaged. This set will also contain any files that are already provided by
    our NuGet dependencies.

    OUTPUTS:
        @(File)                        The files that are being packaged

    =================================================================================================================== -->

  <Target Name="GetFiles"
          Returns="@(File)"
          DependsOnTargets="ConvertItems" />

  <!--
    ===================================================================================================================
    GetFileDependencies
    ===================================================================================================================

    Returns the files coming from the transitive closure of all NuGet dependencies from this package.

    OUTPUTS:
        @(FileDependency)               Files coming from dependencies

    =================================================================================================================== -->

  <Target Name="GetFileDependencies"
          DependsOnTargets="GetNuProjFileDependencies;GetNuGetFileDependencies"
          Returns="@(FileDependency)">
      <ItemGroup>
          <FileDependency Include="@(NuProjFileDependency)" />
          <FileDependency Include="@(NuGetFileDependency)" />
      </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    GetNuProjFileDependencies
    ===================================================================================================================

    Returns the files coming from the transitive closure of all NuGet dependencies from this package.

    OUTPUTS:
        @(FileDependency)               Files coming from dependencies

    =================================================================================================================== -->

  <Target Name="GetNuProjFileDependencies"
          Returns="@(NuProjFileDependency)"
          DependsOnTargets="SplitProjectReferences">
      <MSBuild Targets="GetPackageFiles"
               Projects="@(_NuProjProjectReference)"
               Properties="$(ProjectProperties)">
        <Output TaskParameter="TargetOutputs"
                ItemName="NuProjFileDependency" />
      </MSBuild>
  </Target>

  <!--
    ===================================================================================================================
    GetNuGetFileDependencies
    ===================================================================================================================

    Returns the files coming from the transitive closure of all NuGet dependencies from this package.

    OUTPUTS:
        @(NuGetFileDependency)               Files coming from dependencies

    =================================================================================================================== -->

  <Target Name="GetNuGetFileDependencies"
          Returns="@(NuGetFileDependency)"
          DependsOnTargets="GetNuGetPackageDependencies">
      <ItemGroup>
        <NuGetFileDependency Include="%(NuGetDependency.PackageDirectoryPath)\**\*"
                             Condition="'%(NuGetDependency.PackageDirectoryPath)' != ''" />
      </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    GetPackageDependencies
    ===================================================================================================================

    Get the direct package dependencies of this package. It doesn't include dependencies of dependencies.

    OUTPUTS:
        @(Dependency)               The NuGet dependencies of this package.

    =================================================================================================================== -->

  <Target Name="GetPackageDependencies"
          DependsOnTargets="GetNuProjPackageDependencies;GetNuGetPackageDependencies"
          Returns="@(Dependency)">
    <ItemGroup>
      <Dependency Include="@(NuProjDependency)" />
      <Dependency Include="@(NuGetDependency)" />
    </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    GetNuProjPackageDependencies
    ===================================================================================================================

    Get the direct package dependencies that come from other .nuproj files.

    OUTPUTS:
        @(NuProjDependency)               The NuGet dependencies of this package.

    =================================================================================================================== -->

  <Target Name="GetNuProjPackageDependencies"
          Returns="@(NuProjDependency)"
          DependsOnTargets="SplitProjectReferences">
      <MSBuild Targets="GetPackageIdentity"
               Projects="@(_NuProjProjectReference)"
               Properties="$(ProjectProperties)">
        <Output TaskParameter="TargetOutputs"
                ItemName="NuProjDependency" />
      </MSBuild>
  </Target>

  <!--
    ===================================================================================================================
    GetPackagesConfigFiles
    ===================================================================================================================

    Get the packages configuration files that come from closure of regular, i.e. non-.nuproj NuGet dependencies.

    INPUTS:
        @(ProjectReferenceClosure)      The closure of project references to be packaged

    OUTPUTS:
        @(PackagesConfig)               The NuGet dependencies of this package.

    =================================================================================================================== -->
  
  <Target Name="GetPackagesConfigFiles"
          DependsOnTargets="ExpandProjectReferences;ProjectReferenceClosure"
          Returns="@(PackagesConfig)">

    
    <Message Text="--@(ProjectReferenceClosure, '%0a--')" />
    <ItemGroup>
      <!-- Prepare packages config for project files. -->
      <_ProjectReferenceConfig Include="@(ProjectReferenceClosure)">
        <SpecificForProject Condition=" '$(OS)' == 'Windows_NT'">%(ProjectReferenceClosure.RootDir)%(ProjectReferenceClosure.Directory)packages.$([System.String]::Copy('%(ProjectReferenceClosure.Filename)').Replace(' ','_')).config</SpecificForProject>
        <SpecificForProject Condition=" '$(OS)' != 'Windows_NT'">%(ProjectReferenceClosure.RootDir)%(ProjectReferenceClosure.Directory)packages.%(ProjectReferenceClosure.Filename).config</SpecificForProject>
        <DefaultInDirectory>%(ProjectReferenceClosure.RootDir)%(ProjectReferenceClosure.Directory)packages.config</DefaultInDirectory>
      </_ProjectReferenceConfig>

      <!-- Prepare existing packages config files. Project specific config files have precedence. -->
      <PackagesConfig Include="@(_ProjectReferenceConfig->'%(SpecificForProject)')"
                       Condition="Exists(%(_ProjectReferenceConfig.SpecificForProject))">
        <MSBuildSourceProjectFile>%(_ProjectReferenceConfig.Identity)</MSBuildSourceProjectFile>
      </PackagesConfig>
      <PackagesConfig Include="@(_ProjectReferenceConfig->'%(DefaultInDirectory)')"
                       Condition="Exists(%(_ProjectReferenceConfig.DefaultInDirectory)) And !Exists(%(_ProjectReferenceConfig.SpecificForProject))">
        <MSBuildSourceProjectFile>%(_ProjectReferenceConfig.Identity)</MSBuildSourceProjectFile>
      </PackagesConfig>
    </ItemGroup>
  </Target>

  

  <!--
    ===================================================================================================================
    GetNuGetPackageDependencies
    ===================================================================================================================

    Get the closure of package dependencies that come from regular, i.e. non-.nuproj NuGet dependencies.

    OUTPUTS:
        @(NuGetDependency)               The NuGet dependencies of this package.

    =================================================================================================================== -->

  <Target Name="GetNuGetPackageDependencies"
          DependsOnTargets="GetPackagesConfigFiles"
          Returns="@(NuGetDependency)">
    <ReadPackagesConfig PackagesConfigPath="%(PackagesConfig.Identity)"
                        Condition="'%(PackagesConfig.Identity)' != ''">
      <Output TaskParameter="Packages"
              ItemName="NuGetDependency" />
    </ReadPackagesConfig>
  </Target>

  <!-- 
    ===================================================================================================================
    GetSourceFiles
    =================================================================================================================== -->

  <Target Name="GetSourceFiles"
          DependsOnTargets="GetPackageFiles"
          Condition="'$(EmbedSourceFiles)' == 'True'"
          Returns="@(_SourceFileWithTargetPath)">
    <ItemGroup>
      <_PdbFiles Include="@(PackageFile)"
                 Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <ReadPdbSourceFiles PdbPath="%(_PdbFiles.Identity)">
      <Output TaskParameter="SourcePaths"
              ItemName="_SourceFile" />
    </ReadPdbSourceFiles>
    <!-- Some compilers (like VB) have source files listed that don't actually exist.
         Since we can only package existing files we'll need to exlude those files. -->
    <ItemGroup>
      <_SourceFile Remove="@(_SourceFile)"
                   Condition="!Exists(%(_SourceFile.Identity))" />
    </ItemGroup>
    <AssignSourceTargetPaths SourceFiles="@(_SourceFile)">
      <Output TaskParameter="SourceFilesWithTargetPath"
              ItemName="_SourceFileWithTargetPath" />
      <Output TaskParameter="SourceFilesWithTargetPath"
              ItemName="PackageFile" />
    </AssignSourceTargetPaths>
  </Target>

  <!--
    ===================================================================================================================
    GetPackageIdentity
    ===================================================================================================================

    Returns an item whose identity is the $(Id). The version is included in custom metadata item Version. This format
    is identitcal to the one used to describe package dependencies.

    OUTPUTS:
        $(_PackageIdentity)               The Id and Version of this package

    =================================================================================================================== -->

  <Target Name="GetPackageIdentity"
          Returns="@(_PackageIdentity)">
    <ItemGroup>
      <_PackageIdentity Include="$(Id)">
        <Version>$(Version)</Version>
      </_PackageIdentity>
    </ItemGroup>
  </Target>

  <!--
    ===================================================================================================================
    Clean, Build, Rebuild
    ===================================================================================================================

    These are the standard targets to clean, build and rebuild a NuGet package.

    =================================================================================================================== -->

  <Target Name="Clean">
    <MSBuild Targets="Clean"
             Projects="@(ProjectReference)"
             Properties="$(ProjectProperties)" />
    <ItemGroup>
      <_ToBeDeleted Include="$(NuSpecPath)" />
      <_ToBeDeleted Include="$(NuGetOutputPath)" />
      <_ToBeDeleted Include="$(NuGetSymbolsOutputPath)" />
    </ItemGroup>
    <Delete Files="@(_ToBeDeleted)" />
  </Target>

  <Target Name="Build" DependsOnTargets="CreatePackage">
    <Message Text="$(MSBuildProjectName) -> $(NuGetOutputPath)"
             Importance="high" />
  </Target>

  <Target Name="Rebuild" DependsOnTargets="Clean;Build" />

  <Import Project="$(CustomAfterNuProjTargets)" Condition="'$(CustomAfterNuProjTargets)' != '' and Exists('$(CustomAfterNuProjTargets)')"/>

</Project>